use rusqlite::Connection;
use rusqlite::{Error, Error::SqlInputError};
use std::fs;

/// Print error message generated by sqlite on fail
fn manage_db_error(result: Result<usize, Error>) {
    if let Err(error) = result {
        if let SqlInputError { msg, .. } = error {
            eprintln!("{msg}");
        }
    }
}

/// Create database tables
pub fn create_database(db_name: &str) -> bool {
    if let Ok(conn) = Connection::open(db_name) {
        // Tables created according to type definition in "types"

        manage_db_error(conn.execute(
            "CREATE TABLE image(
			id TEXT PRIMARY KEY,
			data BLOB);",
            (),
        ));

        manage_db_error(conn.execute(
            "CREATE TABLE album(
				title TEXT PRIMARY KEY,
				artist TEXT,
				cover TEXT,
				track_count INT,
				FOREIGN KEY(cover) REFERENCES image(id));",
            (),
        ));

        manage_db_error(conn.execute(
            "CREATE TABLE song(
        id TEXT PRIMARY KEY,
        path TEXT,
        year INT,
        title TEXT,
        artist TEXT,
        track_number INT,
        cover TEXT,
        album TEXT,
        duration INT,
        FOREIGN KEY(cover) REFERENCES image(id),
        FOREIGN KEY(album) REFERENCES album(title));",
            (),
        ));

        manage_db_error(conn.execute(
            "CREATE TABLE playlist(
          id INT PRIMARY KEY,
          name TEXT,
          song TEXT,
          FOREIGN KEY(song) REFERENCES song(id));",
            (),
        ));
    } else {
        return false;
    }
    true
}

/// Scan audio files inside given directory
///
/// supported format : mp3, m4a, mp4, flac, wav
pub fn scan_audio_files(src_path: &str) -> Vec<String> {
    let extensions = vec!["mp3", "m4a", "mp4", "flac", "wav"];
    let mut list: Vec<String> = vec![];

    for content in fs::read_dir(src_path).unwrap() {
        if let Ok(entry) = content {
            if let Ok(entry_type) = entry.file_type() {
                if entry_type.is_dir() {
                    let path = scan_audio_files(entry.path().to_str().unwrap());
                    list.extend(path);
                } else if entry_type.is_file() {
                    if let Some(extension) = entry.path().extension() {
                        if extensions.contains(&extension.to_str().unwrap()) {
                            list.push(entry.path().to_str().unwrap().to_string());
                        }
                    }
                }
            }
        }
    }

    return list;
}

/// Generate an ID from audio file content using SHA256
pub fn generate_audio_id(src_path: &str) -> String {
    let audio = std::path::Path::new(src_path);
    if audio.is_file() {
        if let Ok(hash) = sha256::try_digest(audio) {
            return hash;
        }
    } else {
        eprintln!("{src_path} is not a path to an audio file.");
    }

    String::new()
}
